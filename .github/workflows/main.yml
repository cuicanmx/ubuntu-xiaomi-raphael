# Enhanced workflow for building kernel and rootfs with multi-distro support

name: Build Raphael RootFS

permissions:
  contents: write

# Controls when the workflow will run
on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      kernel_version:
        description: 'Kernel version and release tag (e.g., 6.18)'
        required: true
        type: string
        default: '6.18'
      distribution:
        description: 'Distribution to build (ubuntu/armbian)'
        required: true
        default: 'ubuntu'
        type: choice
        options:
          - ubuntu
          - armbian
      version:
        description: 'Distribution version'
        required: true
        default: 'noble'
        type: choice
        options:
          - noble
          - jammy
          - focal
      kernel_source:
      description: 'Source of kernel packages (release only)'
      required: true
      default: 'release'
      type: choice
      options:
      - release
      desktop_environment:
        description: 'Desktop environment to install (only for ubuntu)'
        required: false
        default: 'none'
        type: choice
        options:
          - none
          - xfce
          - gnome
          - kde

env:
  KERNEL_VERSION: ${{ github.event.inputs.kernel_version }}
  DISTRIBUTION: ${{ github.event.inputs.distribution }}
  KERNEL_SOURCE: ${{ github.event.inputs.kernel_source }}
  RELEASE_TAG: v${{ github.event.inputs.kernel_version }}
  DESKTOP_ENVIRONMENT: ${{ github.event.inputs.desktop_environment }}

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Build root filesystem
  rootfs:
    name: Build RootFS
    runs-on: ubuntu-24.04-arm  
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup environment variables
      run: |
        echo "Building rootfs for distribution: $DISTRIBUTION"
        echo "Kernel version: $KERNEL_VERSION"
        echo "Kernel source: $KERNEL_SOURCE"
        echo "Release tag: $RELEASE_TAG"
        echo "Desktop environment: $DESKTOP_ENVIRONMENT"
        
    - name: Setup inputs
      run: |
        echo "ğŸš€ Starting rootfs build"
        echo "ğŸ“¦ Distribution: $DISTRIBUTION"
        echo "ğŸ”§ Kernel Version: $KERNEL_VERSION"
        echo "ğŸ“ Kernel Source: $KERNEL_SOURCE"
        if [[ "$KERNEL_SOURCE" == "release" ]]; then
          echo "ğŸ·ï¸  Release Tag: $RELEASE_TAG"
        fi
         
    - name: Download kernel packages from GitHub Release
      if: ${{ github.event.inputs.kernel_source == 'release' }}
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        echo "ğŸ“¥ Downloading kernel packages from GitHub Release: $RELEASE_TAG"
        
        # Download compressed kernel archive only
        echo "ğŸ” Downloading compressed kernel archive..."
        gh release download $RELEASE_TAG \
          --pattern "kernel-${KERNEL_VERSION}-raphael.tar.gz" \
          --pattern "kernel-${KERNEL_VERSION}-raphael.zip" \
          --repo ${{ github.repository }}
        
        # Extract the compressed archive
        if [ -f "kernel-${KERNEL_VERSION}-raphael.tar.gz" ]; then
          echo "ğŸ“¦ Extracting tar.gz archive..."
          tar -xzf "kernel-${KERNEL_VERSION}-raphael.tar.gz"
          echo "âœ… tar.gz archive extracted successfully"
        elif [ -f "kernel-${KERNEL_VERSION}-raphael.zip" ]; then
          echo "ğŸ“¦ Extracting zip archive..."
          unzip -q "kernel-${KERNEL_VERSION}-raphael.zip"
          echo "âœ… zip archive extracted successfully"
        else
          echo "âŒ No compressed kernel archive found for version $KERNEL_VERSION"
          echo "ï¿½ Available files in release:"
          gh release view $RELEASE_TAG --repo ${{ github.repository }} --json assets --jq '.assets[].name'
          exit 1
        fi
        
        # Verify extracted packages
        echo "ğŸ” Verifying extracted kernel packages:"
        
        # Use wildcard pattern to match actual package names with full version
        REQUIRED_PACKAGES=("linux-xiaomi-raphael_*_arm64.deb" 
                          "firmware-xiaomi-raphael_*_arm64.deb"
                          "alsa-xiaomi-raphael_*_arm64.deb")
        
        for pkg_pattern in "${REQUIRED_PACKAGES[@]}"; do
          # Find the actual package file matching the pattern
          pkg_file=$(find . -name "$pkg_pattern" -type f | head -1)
          
          if [ -f "$pkg_file" ]; then
            echo "âœ… Found: $pkg_file"
            dpkg-deb -I "$pkg_file" || echo "âš ï¸ Package verification failed for $pkg_file"
          else
            echo "âŒ Missing package matching pattern: $pkg_pattern"
            echo "ğŸ“ Available files:"
            ls -la *.deb 2>/dev/null || echo "No .deb files found"
            exit 1
          fi
        done
        
    # åˆ é™¤artifactsè·å–æ–¹å¼ï¼Œåªä¿ç•™GitHub Releasesä½œä¸ºå†…æ ¸åŒ…æ¥æº

    - name: Install Dependencies
      run: |
         echo "ğŸ“¦ Installing rootfs build dependencies..."
         sudo apt update
         
         # åŸºç¡€ä¾èµ–åŒ…
         BASE_DEPS="fakeroot cpio kmod rsync wget curl file parted dosfstools e2fsprogs util-linux systemd-container jq kpartx"
         
         # æ ¹æ®æ¶æ„å†³å®šæ˜¯å¦å®‰è£…QEMU
         if [ "$(uname -m)" != "aarch64" ]; then
             echo "ğŸ”§ Running on $(uname -m), installing QEMU for emulation..."
             sudo apt install -y qemu-user-static binfmt-support $BASE_DEPS
         else
             echo "ğŸ”§ Running on ARM64, installing native dependencies..."
             sudo apt install -y binfmt-support $BASE_DEPS
         fi

    - name: Build rootfs
      run: |
         set -e  # Exit on any error
         echo "ğŸš€ Starting rootfs build for distribution: $DISTRIBUTION"
         echo "ğŸ“¦ Kernel version: $KERNEL_VERSION"
         echo "ğŸ–¥ï¸  Desktop environment: $DESKTOP_ENVIRONMENT"
         echo "ğŸ“¥ Kernel source: $KERNEL_SOURCE"
         
         # Set environment variables for the build script
         export KERNEL_VERSION="$KERNEL_VERSION"
         export DISTRIBUTION="$DISTRIBUTION"
         export DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT"
         export KERNEL_SOURCE="$KERNEL_SOURCE"
         export GITHUB_WORKSPACE="$GITHUB_WORKSPACE"
         
         # Build rootfs with error handling
         if ! sudo bash ./raphael-rootfs_build.sh; then
           echo "âŒ RootFS build failed!"
           exit 1
         fi
         echo "âœ… RootFS build completed successfully for $DISTRIBUTION"

    - name: Validate rootfs build artifacts
      run: |
         echo "ğŸ” Validating rootfs build artifacts..."
         
         # Check if rootfs image was created
         ROOTFS_IMAGE="root-${DISTRIBUTION}-${KERNEL_VERSION}.img"
         if [ ! -f "$ROOTFS_IMAGE" ]; then
           echo "âŒ Missing rootfs image file: $ROOTFS_IMAGE"
           echo "ğŸ“ Available files:"
           ls -la *.img || echo "No image files found"
           exit 1
         fi
         
         echo "ğŸ“ RootFS image: $ROOTFS_IMAGE"
         ls -lh "$ROOTFS_IMAGE"
         
         # Basic file validation
         if [ ! -s "$ROOTFS_IMAGE" ]; then
           echo "âŒ RootFS image is empty or invalid"
           exit 1
         fi
         
         # Check file type
         file "$ROOTFS_IMAGE" || echo "âš ï¸ File command not available"
         
         # Enhanced validation: Check partition table
         echo "ğŸ” Checking partition table:"
         sudo fdisk -l "$ROOTFS_IMAGE" || echo "âš ï¸ Partition table check failed"
         
         # Try to mount and verify content
         echo "ğŸ” Verifying RootFS content..."
         sudo kpartx -a "$ROOTFS_IMAGE"
         sleep 2
         
         # Check if root partition exists
         if [ -b /dev/mapper/loop0p2 ]; then
           echo "âœ… Root partition found"
           
           # Mount root partition
           sudo mkdir -p /mnt/rootfs
           sudo mount /dev/mapper/loop0p2 /mnt/rootfs
           
           # Check key files
           key_files=("/mnt/rootfs/etc/hostname" "/mnt/rootfs/etc/fstab" "/mnt/rootfs/boot/vmlinuz*" "/mnt/rootfs/lib/modules")
           for file in "${key_files[@]}"; do
             if [ -e "$file" ]; then
               echo "âœ… Found: $file"
             else
               echo "âŒ Missing: $file"
             fi
           done
           
           # Check kernel modules
           if ls /mnt/rootfs/lib/modules/$KERNEL_VERSION* 1> /dev/null 2>&1; then
             echo "âœ… Kernel modules installed:"
             ls -la /mnt/rootfs/lib/modules/$KERNEL_VERSION*
           else
             echo "âŒ Kernel modules not found"
           fi
           
           # Unmount and cleanup
           sudo umount /mnt/rootfs
           sudo rmdir /mnt/rootfs
         else
           echo "âš ï¸ Could not find root partition"
         fi
         
         # Cleanup loop devices
         sudo kpartx -d "$ROOTFS_IMAGE"
         
         echo "âœ… RootFS artifacts validated successfully"

    - name: Compress rootfs image to zip
      run: |
         echo "ğŸ—œï¸ Compressing rootfs image to zip..."
         ROOTFS_IMAGE="root-${DISTRIBUTION}-${KERNEL_VERSION}.img"
         ZIP_NAME="${ROOTFS_IMAGE%.img}.zip"
         
         # å‹ç¼©é•œåƒæ–‡ä»¶
         zip -9 "$ZIP_NAME" "$ROOTFS_IMAGE"
         
         echo "âœ… Compressed: $ZIP_NAME"
         ls -lh "$ZIP_NAME"
         
    - name: Extract UUID and boot files from rootfs
      run: |
         echo "ğŸ” Extracting UUID and boot files from rootfs image..."
         ROOTFS_IMAGE="root-${DISTRIBUTION}-${KERNEL_VERSION}.img"
         
         # åˆ›å»ºbootæ–‡ä»¶ç›®å½•
         mkdir -p boot-files
         
         # ç›´æ¥æŒ‚è½½rootfsé•œåƒï¼ˆéåˆ†åŒºé•œåƒï¼‰
         echo "ğŸ“‚ Mounting rootfs image directly..."
         sudo mkdir -p /mnt/rootfs
         sudo mount -o loop "$ROOTFS_IMAGE" /mnt/rootfs
         
         # æå–UUIDä¿¡æ¯
         echo "ğŸ“ Extracting UUID information..."
         ROOT_UUID=$(sudo blkid -s UUID -o value "$ROOTFS_IMAGE")
         if [ -n "$ROOT_UUID" ]; then
           echo "Root Filesystem UUID: $ROOT_UUID"
           echo "$ROOT_UUID" > boot-files/rootfs-uuid.txt
           echo "âœ… UUID extracted successfully"
         else
           echo "âŒ Failed to extract UUID from rootfs image"
           exit 1
         fi
         
         # æå–bootæ–‡ä»¶
         echo "ğŸ“ Extracting boot files..."
         
         # æŸ¥æ‰¾å¹¶å¤åˆ¶initrd.imgæ–‡ä»¶
          echo "ğŸ” Searching for initrd.img files..."
          
          # é¦–å…ˆæ£€æŸ¥/bootç›®å½•
          echo "ğŸ“‚ Checking /boot directory..."
          sudo ls -la /mnt/rootfs/boot/ 2>/dev/null || echo "âš ï¸ /boot directory not accessible"
          
          INITRD_FILES=$(sudo find /mnt/rootfs/boot -name "initrd.img-*" 2>/dev/null || true)
          if [ -n "$INITRD_FILES" ]; then
            for initrd_file in $INITRD_FILES; do
              if [ -f "$initrd_file" ]; then
                filename=$(basename "$initrd_file")
                sudo cp "$initrd_file" "boot-files/initrd.img"
                echo "âœ… Copied: $filename -> boot-files/initrd.img"
                break  # åªå–ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶
              fi
            done
          else
            echo "âš ï¸ No initrd.img files found in /mnt/rootfs/boot/"
            
            # æ£€æŸ¥æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿ
            echo "ğŸ” Searching entire filesystem for initrd files..."
            INITRD_FILES=$(sudo find /mnt/rootfs -name "initrd.img-*" 2>/dev/null || true)
            if [ -n "$INITRD_FILES" ]; then
              echo "ğŸ“ Found initrd files in these locations:"
              echo "$INITRD_FILES"
              for initrd_file in $INITRD_FILES; do
                if [ -f "$initrd_file" ]; then
                  filename=$(basename "$initrd_file")
                  sudo cp "$initrd_file" "boot-files/initrd.img"
                  echo "âœ… Copied: $filename -> boot-files/initrd.img"
                  break
                fi
              done
            else
              echo "âŒ No initrd.img files found in the entire filesystem"
              echo "ğŸ“Š Listing /mnt/rootfs directory structure..."
              sudo ls -la /mnt/rootfs/
              exit 1
            fi
          fi
         
         # æŸ¥æ‰¾å¹¶å¤åˆ¶vmlinuzæ–‡ä»¶
          echo "ğŸ” Searching for vmlinuz files..."
          
          # é¦–å…ˆæ£€æŸ¥/bootç›®å½•
          echo "ğŸ“‚ Checking /boot directory for vmlinuz..."
          sudo ls -la /mnt/rootfs/boot/ 2>/dev/null || echo "âš ï¸ /boot directory not accessible"
          
          VMLINUZ_FILES=$(sudo find /mnt/rootfs/boot -name "vmlinuz-*" 2>/dev/null || true)
          if [ -n "$VMLINUZ_FILES" ]; then
            for vmlinuz_file in $VMLINUZ_FILES; do
              if [ -f "$vmlinuz_file" ]; then
                filename=$(basename "$vmlinuz_file")
                sudo cp "$vmlinuz_file" "boot-files/vmlinuz"
                echo "âœ… Copied: $filename -> boot-files/vmlinuz"
                break  # åªå–ç¬¬ä¸€ä¸ªåŒ¹é…çš„æ–‡ä»¶
              fi
            done
          else
            echo "âš ï¸ No vmlinuz files found in /mnt/rootfs/boot/"
            
            # æ£€æŸ¥æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿ
            echo "ğŸ” Searching entire filesystem for vmlinuz files..."
            VMLINUZ_FILES=$(sudo find /mnt/rootfs -name "vmlinuz-*" 2>/dev/null || true)
            if [ -n "$VMLINUZ_FILES" ]; then
              echo "ğŸ“ Found vmlinuz files in these locations:"
              echo "$VMLINUZ_FILES"
              for vmlinuz_file in $VMLINUZ_FILES; do
                if [ -f "$vmlinuz_file" ]; then
                  filename=$(basename "$vmlinuz_file")
                  sudo cp "$vmlinuz_file" "boot-files/vmlinuz"
                  echo "âœ… Copied: $filename -> boot-files/vmlinuz"
                  break
                fi
              done
            else
              echo "âŒ No vmlinuz files found in the entire filesystem"
              echo "ğŸ“Š Listing /mnt/rootfs directory structure..."
              sudo ls -la /mnt/rootfs/
              exit 1
            fi
          fi
         
         # éªŒè¯æå–çš„æ–‡ä»¶
         echo "ğŸ” Verifying extracted files..."
         ls -la boot-files/
         
         # æ£€æŸ¥æ–‡ä»¶å¤§å°å’Œç±»å‹
         if [ -f "boot-files/initrd.img" ]; then
           echo "ğŸ“Š initrd.img: $(ls -lh boot-files/initrd.img | cut -d' ' -f5)"
           file "boot-files/initrd.img"
         fi
         
         if [ -f "boot-files/vmlinuz" ]; then
           echo "ğŸ“Š vmlinuz: $(ls -lh boot-files/vmlinuz | cut -d' ' -f5)"
           file "boot-files/vmlinuz"
         fi
         
         if [ -f "boot-files/rootfs-uuid.txt" ]; then
           echo "ğŸ“„ UUID: $(cat boot-files/rootfs-uuid.txt)"
         fi
         
         # å¸è½½å¹¶æ¸…ç†
         sudo umount /mnt/rootfs
         sudo rmdir /mnt/rootfs
         
         echo "âœ… UUID and boot files extraction completed"

    - name: Create boot package
      run: |
         echo "ğŸ“¦ Creating boot package..."
         
         # åˆ›å»ºbootåŒ…
         BOOT_PACKAGE="boot-files-${DISTRIBUTION}-${KERNEL_VERSION}.zip"
         
         # å‹ç¼©bootæ–‡ä»¶
         if [ -d "boot-files" ]; then
           zip -9 "$BOOT_PACKAGE" -r boot-files/
           echo "âœ… Boot package created: $BOOT_PACKAGE"
           ls -lh "$BOOT_PACKAGE"
           
           # éªŒè¯bootåŒ…å®Œæ•´æ€§
           echo "ğŸ” Verifying boot package integrity..."
           if [ -f "$BOOT_PACKAGE" ]; then
             echo "âœ… Boot package file exists"
             
             # æ£€æŸ¥æ–‡ä»¶å¤§å°
             BOOT_SIZE=$(stat -c%s "$BOOT_PACKAGE")
             if [ "$BOOT_SIZE" -gt 1000000 ]; then  # è‡³å°‘1MB
               echo "âœ… Boot package size is reasonable: $BOOT_SIZE bytes"
             else
               echo "âš ï¸ Boot package size seems too small: $BOOT_SIZE bytes"
             fi
             
             # éªŒè¯zipæ–‡ä»¶ç»“æ„
             if unzip -l "$BOOT_PACKAGE" | grep -q "boot-files/"; then
               echo "âœ… Boot package contains boot-files directory"
             else
               echo "âŒ Boot package does not contain boot-files directory"
               exit 1
             fi
             
             # éªŒè¯å…·ä½“æ–‡ä»¶
             unzip -l "$BOOT_PACKAGE" | grep -E "(rootfs-uuid.txt|vmlinuz|initrd.img)" || echo "âš ï¸ Some expected files not found in package listing"
             
           else
             echo "âŒ Boot package file not created"
             exit 1
           fi
           
           echo "âœ… Boot package integrity verified successfully"
         else
           echo "âŒ boot-files directory not found"
           exit 1
         fi

    - name: Upload to GitHub Release
      if: github.event.inputs.release_tag != ''
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.event.inputs.release_tag }}
        name: "ğŸ¯ å°ç±³ Raphael ${{ github.event.inputs.distribution }} å‘è¡Œç‰ˆ - å†…æ ¸ ${{ github.event.inputs.kernel_version }}"
        body: |
          # ğŸ¯ å°ç±³ Raphael (K20 Pro) ${{ github.event.inputs.distribution }} å‘è¡Œç‰ˆ
          
          ## ğŸ“¦ å‘è¡Œç‰ˆä¿¡æ¯
          
          ### ğŸ·ï¸ åŸºæœ¬ä¿¡æ¯
          - **è®¾å¤‡å‹å·**: å°ç±³ Raphael (K20 Pro)
          - **å‘è¡Œç‰ˆæœ¬**: ${{ github.event.inputs.distribution }}
          - **å†…æ ¸ç‰ˆæœ¬**: ${{ github.event.inputs.kernel_version }}
          - **æ¡Œé¢ç¯å¢ƒ**: ${{ github.event.inputs.desktop_environment }}
          - **æ¶æ„å¹³å°**: ARM64
          
          ### ğŸ“Š æ„å»ºè¯¦æƒ…
          - **æ„å»ºæ—¥æœŸ**: ${{ github.event.repository.created_at }}
          - **æ„å»ºID**: ${{ github.run_id }}
          - **å‘å¸ƒæ ‡ç­¾**: ${{ github.event.inputs.release_tag }}
          
          ## ğŸ—‚ï¸ æ–‡ä»¶è¯´æ˜
          
          ### ğŸ”§ RootFS ç³»ç»Ÿé•œåƒ
          - **å®Œæ•´é•œåƒ**: root-${{ github.event.inputs.distribution }}-${{ github.event.inputs.kernel_version }}.img
          - **å‹ç¼©ç‰ˆæœ¬**: root-${{ github.event.inputs.distribution }}-${{ github.event.inputs.kernel_version }}.zip (æ¨èç”¨äºå¯åŠ¨é•œåƒæ„å»º)
          
          ### ğŸš€ å¯åŠ¨æ–‡ä»¶åŒ…
          - **å¯åŠ¨åŒ…**: boot-files-${{ github.event.inputs.distribution }}-${{ github.event.inputs.kernel_version }}.zip
            - åŒ…å« UUIDã€initrd.img å’Œ vmlinuz æ–‡ä»¶
            - ç”¨äºå¯åŠ¨é•œåƒåˆ›å»º
          
          ## ğŸ“‹ ä½¿ç”¨æŒ‡å—
          
          ### ğŸ”¥ åˆ·æœºè¯´æ˜
          ```bash
          # è§£å‹ RootFS é•œåƒ
          unzip root-${{ github.event.inputs.distribution }}-${{ github.event.inputs.kernel_version }}.zip
          
          # åˆ·å…¥è®¾å¤‡ (æ ¹æ®æ‚¨çš„è®¾ç½®è°ƒæ•´)
          fastboot flash system root-${{ github.event.inputs.distribution }}-${{ github.event.inputs.kernel_version }}.img
          ```
          
          ### ğŸ’¡ ä½¿ç”¨æç¤º
          - å¯åŠ¨é•œåƒæ„å»ºæ—¶ï¼Œå»ºè®®ä¸‹è½½ .zip æ–‡ä»¶ä»¥è·å¾—æ›´å¿«çš„ä¼ è¾“é€Ÿåº¦
          - ä½¿ç”¨å‰è¯·ä» .zip æ–‡ä»¶ä¸­æå– .img é•œåƒæ–‡ä»¶
          - ç¡®ä¿è®¾å¤‡å·²è§£é” bootloader
          - å»ºè®®åœ¨åˆ·æœºå‰å¤‡ä»½é‡è¦æ•°æ®
          
          ## ğŸ¯ è®¾å¤‡å…¼å®¹æ€§
          
          ### âœ… æ”¯æŒè®¾å¤‡
          - å°ç±³ Raphael (K20 Pro)
          - åŸºäº SM8150 å¹³å°çš„è®¾å¤‡
          
          ### ğŸ”§ ç¡¬ä»¶è¦æ±‚
          - ARM64 æ¶æ„å¤„ç†å™¨
          - è‡³å°‘ 2GB å¯ç”¨å­˜å‚¨ç©ºé—´
          - å·²è§£é”çš„ bootloader
          
          ## ğŸ“ æ›´æ–°æ—¥å¿—
          
          ### ğŸ”„ ç‰ˆæœ¬æ›´æ–°
          - **å†…æ ¸ç‰ˆæœ¬**: ${{ github.event.inputs.kernel_version }}
          - **å‘è¡Œç‰ˆæœ¬**: ${{ github.event.inputs.distribution }}
          - **æ¡Œé¢ç¯å¢ƒ**: ${{ github.event.inputs.desktop_environment }}
          
          ### âœ¨ åŠŸèƒ½ç‰¹æ€§
          - å®Œæ•´çš„ Linux å‘è¡Œç‰ˆä½“éªŒ
          - ä¼˜åŒ–çš„ ARM64 æ€§èƒ½
          - é’ˆå¯¹å°ç±³ Raphael è®¾å¤‡çš„ä¸“é—¨ä¼˜åŒ–
          - ç¨³å®šçš„å†…æ ¸å’Œç³»ç»Ÿç»„ä»¶
          
          ## â“ å¸¸è§é—®é¢˜
          
          ### Q: å¦‚ä½•éªŒè¯é•œåƒå®Œæ•´æ€§ï¼Ÿ
          A: ä¸‹è½½åæ£€æŸ¥æ–‡ä»¶å¤§å°å’Œå“ˆå¸Œå€¼ï¼Œç¡®ä¿æ–‡ä»¶å®Œæ•´ã€‚
          
          ### Q: æ˜¯å¦éœ€è¦ç‰¹æ®Šå·¥å…·ï¼Ÿ
          A: éœ€è¦ fastboot å·¥å…·å’Œå·²è§£é”çš„ bootloaderã€‚
          
          ### Q: æ”¯æŒå“ªäº›æ¡Œé¢ç¯å¢ƒï¼Ÿ
          A: å½“å‰æ”¯æŒ ${{ github.event.inputs.desktop_environment }} æ¡Œé¢ç¯å¢ƒã€‚
          
          ---
          
          *ğŸ’« ç”± GitHub Actions è‡ªåŠ¨æ„å»ºï¼Œä¸“ä¸ºå°ç±³ Raphael è®¾å¤‡ä¼˜åŒ–*